import numpy as np
from gca_time import preprocessing


def save_error(error, norm, HyperParams, vars):
    """
    save_error(error: List[float], norm: List[float], HyperParams: object, vars: str)

    This function takes in two lists of same length, error and norm, computed on the whole dataset for plotting reasons, and saves the relative error, along with the max, mean and min to a txt file.

    The relative error is calculated as error/norm for each corresponding element. The file is saved with a specific naming convention: HyperParams.net_dir + 'relative_errors' + HyperParams.net_run + vars + '.txt'

    Parameters:
    error (List[float]): A list of error values.
    norm (List[float]): A list of norm values of same length as error.
    HyperParams (object): An object containing information required to form the file name.
    vars (str): A string to be appended to the file name.
    """

    error = np.array(error)
    norm = np.array(norm)
    rel_error = error/norm
    np.savetxt(HyperParams.net_dir+'relative_errors'+HyperParams.net_run+vars+'.txt', [max(rel_error), sum(rel_error)/len(rel_error), min(rel_error)])


def print_error(error, norm, vars):
    """
    print_error(error: List[float], norm: List[float], vars: str)

    This function takes in two lists error and norm of same length and prints their absolute and relative errors, along with the max, mean and min of both the absolute and relative errors.

    The relative error is calculated as error/norm for each corresponding elements.

    Parameters:
    error (List[float]): A list of error values.
    norm (List[float]): A list of norm values of same length as error.
    vars (str): A string to describe the type of field.
    """

    error = np.array(error)
    norm = np.array(norm)
    rel_error = error/norm
    print("\nMaximum absolute error for field "+vars+" = ", max(error))
    print("Mean absolute error for field "+vars+" = ", sum(error)/len(error))
    print("Minimum absolute error for field "+vars+" = ", min(error))
    print("\nMaximum relative error for field "+vars+" = ", max(rel_error))
    print("Mean relative error for field "+vars+" = ", sum(rel_error)/len(rel_error))
    print("Minimum relative error for field "+vars+" = ", min(rel_error))


def compute_error(results, dataset, scaler_all, HyperParams, test_trajectories):
    """
    Compute the absolute error and norm between the original data and the data generated by the autoencoder

    :param res: Resulting data generated by the autoencoder (numpy ndarray)
    :param VAR: Original data (numpy ndarray)
    :param scaler: Scaler object for scaling the data
    :param HyperParams: Autoencoder parameters (object)
    :return: error_abs_list, norm_z_list, lists of absolute error and norm for each snapshot of data
    """

    error_abs_list = list()
    norm_z_list = list()
    Z_net = np.zeros((len(test_trajectories), dataset.VX.shape[0],2))
    ground_truth = np.zeros((len(test_trajectories), dataset.VX.shape[0],2))
    count = 0
    for i in test_trajectories:
        out = preprocessing.inverse_normalize_input(results[i, :, :], scaler_all, i, HyperParams)
        out = out.detach().numpy()
        Z_net[count, :, :] = out
        ground_truth[count, :, :] = np.column_stack((dataset.VX[:, i], dataset.VY[:, i]))
        count += 1
    # Take only the magnitude of velocity
    Z_net = np.linalg.norm(Z_net, axis=2)
    Z_net = np.transpose(Z_net)
    ground_truth = np.linalg.norm(ground_truth, axis=2)
    ground_truth = np.transpose(ground_truth)
    

    for snap in range(len(test_trajectories)):
        error_abs = np.linalg.norm(abs(ground_truth[:, snap] - Z_net[:, snap]))
        norm_z = np.linalg.norm(ground_truth[:, snap], 2)
        error_abs_list.append(error_abs)
        norm_z_list.append(norm_z)
    return error_abs_list, norm_z_list
